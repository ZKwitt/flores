<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catálogo — Marrie</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --bg1: #fef6fa;
      --bg2: #f5f0ff;
      --primary: #ff6b9d;
      --secondary: #c66fbc;
      --accent: #66d9ef;
      --muted: #8b7f99;
      --card-bg: rgba(255,255,255,0.98);
      --soft-shadow: 0 20px 60px rgba(150,100,200,0.08);
      --hover-shadow: 0 25px 70px rgba(150,100,200,0.12);
      --gradient1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient3: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      --gradient-soft: linear-gradient(135deg, rgba(255,107,157,0.1) 0%, rgba(102,217,239,0.1) 100%);
    }
    body{
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background:
        radial-gradient(ellipse at top left, rgba(255,182,193,0.3) 0%, transparent 50%),
        radial-gradient(ellipse at top right, rgba(221,160,221,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at bottom left, rgba(176,224,230,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(255,218,185,0.2) 0%, transparent 50%),
        linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
      min-height:100vh;
      padding:36px;
      color:#2a2438;
      position: relative;
      overflow-x: hidden;
    }

    /* (CSS mantengo igual que en tu diseño original — aquí resumido por brevedad, se conserva idéntico) */
    /* animated gradient orbs */
    body::before, body::after {
      content: '';
      position: fixed;
      border-radius: 50%;
      filter: blur(100px);
      opacity: 0.3;
      pointer-events: none;
      animation: float 20s ease-in-out infinite;
    }
    body::before { width: 600px; height: 600px; background: linear-gradient(135deg, #667eea, #ff6b9d); top: -200px; left: -200px; }
    body::after { width: 500px; height: 500px; background: linear-gradient(135deg, #66d9ef, #f093fb); bottom: -150px; right: -150px; animation-delay: -10s; }
    @keyframes float { 0%, 100% { transform: translate(0, 0) scale(1); } 25% { transform: translate(30px, -30px) scale(1.05); } 50% { transform: translate(-20px, 20px) scale(0.95); } 75% { transform: translate(-30px, -10px) scale(1.02); } }
    .header{ text-align:center; margin-bottom:30px; position:relative; z-index:1; animation: fadeInDown 0.8s ease; }
    .header h1{ font-size:2.8rem; font-weight:900; background: var(--gradient2); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; margin-bottom:8px; letter-spacing:-0.02em; filter: drop-shadow(2px 2px 20px rgba(255,107,157,0.3)); }
    .header p{ color:var(--muted); font-size:1.1rem; font-weight:500; letter-spacing:0.5px; }
    @keyframes fadeInDown { from { opacity:0; transform:translateY(-20px); } to { opacity:1; transform:translateY(0); } }
    #tabs{ display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin:20px 0 30px; z-index:1; position:relative; animation: fadeIn 1s ease 0.3s both; }
    .tab{ background: var(--card-bg); padding:10px 20px; border-radius:999px; border:2px solid rgba(255,107,157,0.1); font-weight:600; cursor:pointer; color:#5a4a6b; transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow:0 4px 15px rgba(0,0,0,0.05); position:relative; overflow:hidden; }
    .tab::before{ content:''; position:absolute; inset:0; background: var(--gradient-soft); opacity:0; transition:opacity 0.3s; }
    .tab:hover{ transform:translateY(-3px); box-shadow:0 8px 25px rgba(255,107,157,0.15); border-color:rgba(255,107,157,0.3); }
    .tab:hover::before{ opacity:1; }
    .tab.active{ background: var(--gradient2); color:#fff; border-color:transparent; box-shadow:0 10px 30px rgba(255,107,157,0.25); transform:scale(1.05); }
    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
    #content { max-width:1200px; margin: 0 auto; min-height:160px; text-align:center; z-index:1; animation: fadeInUp 0.8s ease 0.5s both; }
    @keyframes fadeInUp { from { opacity:0; transform:translateY(20px); } to { opacity:1; transform:translateY(0); } }
    .loading { text-align:center; padding:60px 0; color:var(--muted); font-weight:600; font-size:1.1rem; }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(320px,1fr)); gap:25px; align-items:start; }
    .card { position:relative; perspective:1000px; animation: cardEntry 0.6s ease both; animation-delay: calc(var(--card-index, 0) * 0.05s); }
    @keyframes cardEntry { from { opacity:0; transform:translateY(30px) scale(0.95); } to { opacity:1; transform:translateY(0) scale(1); } }
    .flip-inner { position:relative; width:100%; min-height:440px; border-radius:24px; overflow:visible; transition: none; }
    .face { position:absolute; inset:0; border-radius:24px; overflow:hidden; box-shadow: var(--soft-shadow); transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); background: var(--card-bg); border:1px solid rgba(255,255,255,0.8); display:flex; flex-direction:column; justify-content:space-between; padding-bottom:16px; backface-visibility:hidden; backdrop-filter: blur(10px); }
    .face::before { content:''; position:absolute; inset:0; background: var(--gradient-soft); opacity:0.3; pointer-events:none; border-radius:24px; }
    .face.front{ opacity:1; transform: translateY(0) rotateX(0); visibility:visible; z-index:2; position:relative; }
    .face.back{ opacity:0; transform: translateY(10px) rotateX(-10deg); visibility:hidden; z-index:1; }
    .flip-inner.flipped .face.front{ opacity:0; transform: translateY(-10px) rotateX(10deg); visibility:hidden; z-index:1; }
    .flip-inner.flipped .face.back{ opacity:1; transform: translateY(0) rotateX(0); visibility:visible; z-index:2; }
    .eye-toggle { position:absolute; left:16px; top:16px; width:48px; height:48px; border-radius:16px; display:flex; align-items:center; justify-content:center; background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85)); border:2px solid rgba(255,107,157,0.15); cursor:pointer; z-index:10; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow:0 8px 20px rgba(0,0,0,0.08); }
    .eye-toggle:hover{ transform:scale(1.1) rotate(5deg); box-shadow:0 12px 30px rgba(255,107,157,0.2); border-color:rgba(255,107,157,0.3); background: linear-gradient(135deg, #fff, rgba(255,107,157,0.1)); }
    .eye-toggle:active{ transform:scale(0.95); }
    .front-image { width:130px; height:130px; border-radius:50%; overflow:hidden; margin:30px auto 16px; box-shadow: 0 20px 40px rgba(255,107,157,0.15), 0 0 0 6px rgba(255,255,255,0.5), 0 0 0 12px rgba(255,107,157,0.1); background: linear-gradient(135deg, #fff, #fef0f5); display:flex; align-items:center; justify-content:center; font-size:52px; position:relative; z-index:1; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
    .card:hover .front-image { transform: scale(1.05) rotate(3deg); }
    .product-img{ width:100%; height:100%; object-fit:cover; display:block; }
    .name { font-weight:700; text-align:center; margin-top:8px; font-size:1.15rem; color:#2a2438; padding:0 20px; position:relative; z-index:1; }
    .cat { font-size:13px; color:var(--muted); text-align:center; margin-top:8px; font-weight:500; position:relative; z-index:1; }
    .meta { padding:10px 20px 0; display:flex; flex-direction:column; gap:12px; align-items:center; position:relative; z-index:1; }
    .price { font-size:1.6rem; font-weight:800; text-align:center; background: var(--gradient2); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; }
    .stock { font-size:.9rem; padding:8px 16px; border-radius:999px; color:#fff; font-weight:700; background: var(--gradient3); box-shadow:0 4px 15px rgba(255,107,157,0.2); }
    .actions{ display:flex; gap:12px; align-items:center; justify-content:center; padding:12px 20px 10px; position:relative; z-index:1; }
    .small{ width:36px; height:36px; border-radius:12px; border:2px solid rgba(255,107,157,0.15); background:linear-gradient(135deg, #fff, rgba(255,107,157,0.05)); cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; color:#5a4a6b; transition:all 0.2s; box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    .small:hover{ transform:scale(1.1); border-color:rgba(255,107,157,0.3); box-shadow:0 6px 15px rgba(255,107,157,0.15); }
    .qty{ min-width:36px; text-align:center; font-weight:800; font-size:1.1rem; color:#2a2438; }
    .btn.order { background: var(--gradient2); color:#fff; padding:12px 24px; border-radius:999px; border:0; cursor:pointer; font-weight:700; font-size:0.95rem; letter-spacing:0.5px; transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow:0 8px 20px rgba(255,107,157,0.25); }
    .btn.order:hover:not([disabled]){ transform:translateY(-2px); box-shadow:0 12px 30px rgba(255,107,157,0.35); }
    .btn.order:active:not([disabled]){ transform:translateY(0); }
    .btn.order[disabled]{ opacity:.4; cursor:not-allowed; background: linear-gradient(135deg, #ccc, #999); }
    .back-image-wrap { width:calc(100% - 24px); height:240px; border-radius:20px; overflow:hidden; display:flex; align-items:center; justify-content:center; background: linear-gradient(135deg, #fef0f5, #f0f4ff); margin:10px 12px 8px; position:relative; z-index:1; box-shadow: inset 0 2px 10px rgba(0,0,0,0.05); }
    .back-image { width:100%; height:100%; object-fit:contain; display:block; cursor:zoom-in; transition: transform 0.3s; border-radius:20px; }
    .back-image:hover { transform: scale(1.05); }
    .desc-box { width:calc(100% - 24px); max-height:120px; overflow:auto; margin:0 12px 10px; padding:14px; border-radius:16px; background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(255,240,245,0.9)); border:1px solid rgba(255,107,157,0.1); font-size:0.95rem; color:#5a4a6b; line-height:1.6; position:relative; z-index:1; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
    .desc-box::-webkit-scrollbar { width: 6px; }
    .desc-box::-webkit-scrollbar-track { background: rgba(255,107,157,0.05); border-radius: 10px; }
    .desc-box::-webkit-scrollbar-thumb { background: rgba(255,107,157,0.3); border-radius: 10px; }
    .desc-box::-webkit-scrollbar-thumb:hover { background: rgba(255,107,157,0.5); }
    #cart-btn { position: fixed; bottom: 30px; right: 30px; background: var(--gradient2); color: #fff; padding: 16px 24px; border-radius: 999px; border: none; cursor: pointer; display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 1rem; box-shadow: 0 10px 30px rgba(255,107,157,0.3); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 1000; animation: cartBounce 2s ease infinite; }
    @keyframes cartBounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
    #cart-btn:hover { transform: translateY(-3px) scale(1.05); box-shadow: 0 15px 40px rgba(255,107,157,0.4); }
    #cart-icon { font-size: 1.3rem; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.1)); }
    #cart-count { background: #fff; color: var(--primary); padding: 4px 10px; border-radius: 999px; font-size: 0.85rem; font-weight: 800; min-width: 24px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
    #cart-popup-overlay { position: fixed; inset: 0; background: rgba(30,20,50,0.7); backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; z-index: 10000; padding: 20px; animation: fadeIn 0.3s ease; }
    #cart-popup { background: linear-gradient(135deg, #fff 0%, #fef5f8 100%); border-radius: 24px; padding: 30px; max-width: 500px; width: 100%; max-height: 80vh; overflow: auto; box-shadow: 0 30px 60px rgba(255,107,157,0.2), 0 0 0 1px rgba(255,255,255,0.5); animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1); border: 2px solid rgba(255,107,157,0.1); }
    @keyframes slideUp { from { opacity: 0; transform: translateY(30px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
    #cart-popup h3 { font-size: 1.8rem; margin-bottom: 20px; background: var(--gradient2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-align: center; font-weight: 800; }
    #cart-items-container { margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.7); border-radius: 16px; border: 1px solid rgba(255,107,157,0.1); max-height: 350px; overflow-y: auto; }
    .cart-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(255,240,245,0.9)); border-radius: 12px; border: 1px solid rgba(255,107,157,0.08); transition: all 0.2s; }
    .cart-item:hover { transform: translateX(5px); box-shadow: 0 5px 15px rgba(255,107,157,0.1); }
    .cart-item-name { font-weight: 600; color: #2a2438; flex: 1; }
    .cart-item-qty { background: var(--gradient3); color: #fff; padding: 4px 12px; border-radius: 999px; font-weight: 700; font-size: 0.85rem; margin: 0 10px; }
    .cart-item-price { font-weight: 700; color: var(--primary); }
    .cart-item-remove { background: rgba(255,107,157,0.1); color: var(--primary); border: none; padding: 6px 10px; border-radius: 8px; cursor: pointer; margin-left: 10px; transition: all 0.2s; font-weight: 600; }
    .cart-item-remove:hover { background: rgba(255,107,157,0.2); transform: scale(1.05); }
    #cart-total { text-align: center; font-size: 1.3rem; font-weight: 800; padding: 15px; background: var(--gradient-soft); border-radius: 12px; margin-top: 15px; color: #2a2438; }
    #cart-confirm { background: var(--gradient2); color: #fff; padding: 14px 28px; border-radius: 999px; border: none; font-weight: 700; cursor: pointer; box-shadow: 0 8px 20px rgba(255,107,157,0.25); transition: all 0.3s; font-size: 1rem; }
    #cart-confirm:hover { transform: translateY(-2px); box-shadow: 0 12px 30px rgba(255,107,157,0.35); }
    #cart-close { background: rgba(255,255,255,0.9); color: var(--muted); padding: 12px 20px; border-radius: 999px; border: 2px solid rgba(0,0,0,0.05); font-weight: 600; cursor: pointer; transition: all 0.2s; }
    #cart-close:hover { border-color: rgba(255,107,157,0.2); background: #fff; color: var(--primary); }
    #cart-items-container::-webkit-scrollbar { width: 8px; }
    #cart-items-container::-webkit-scrollbar-track { background: rgba(255,107,157,0.05); border-radius: 10px; }
    #cart-items-container::-webkit-scrollbar-thumb { background: rgba(255,107,157,0.3); border-radius: 10px; }
    #cart-items-container::-webkit-scrollbar-thumb:hover { background: rgba(255,107,157,0.5); }
    #img-modal-overlay { position:fixed; inset:0; display:none; background:rgba(30,20,50,0.85); backdrop-filter: blur(15px); align-items:center; justify-content:center; z-index:20000; padding:20px; animation: fadeIn 0.3s ease; }
    #img-modal { max-width:95vw; max-height:95vh; overflow:auto; border-radius:20px; box-shadow:0 30px 80px rgba(255,107,157,0.3); background:linear-gradient(135deg, #fff, #fef5f8); display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px; border: 2px solid rgba(255,107,157,0.1); animation: zoomIn 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
    @keyframes zoomIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
    #img-modal img { max-width:100%; max-height:80vh; object-fit:contain; display:block; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
    #img-modal-close { align-self:flex-end; margin-bottom:10px; background: linear-gradient(135deg, #fff, rgba(255,107,157,0.1)); color: var(--primary); padding: 10px 20px; border-radius: 999px; border: 2px solid rgba(255,107,157,0.2); font-weight: 600; cursor: pointer; transition: all 0.2s; }
    #img-modal-close:hover { transform: scale(1.05); background: var(--gradient2); color: #fff; border-color: transparent; }
    @media (max-width:768px) { .header h1 { font-size: 2.2rem; } .grid { grid-template-columns: repeat(auto-fill, minmax(280px,1fr)); gap: 20px; } #cart-btn { bottom: 20px; right: 20px; padding: 14px 20px; } }
    @media (max-width:520px) { body { padding: 20px; } .header h1 { font-size: 1.8rem; } .grid { grid-template-columns: 1fr; } .front-image { width: 110px; height: 110px; } .flip-inner { min-height: 400px; } .back-image-wrap { height: 200px; } #cart-popup { padding: 20px; } #cart-btn { bottom: 15px; right: 15px; padding: 12px 18px; font-size: 0.9rem; } }
    .loading::after { content: '...'; animation: dots 1.5s steps(4, end) infinite; }
    @keyframes dots { 0%, 20% { content: '.'; } 40% { content: '..'; } 60%, 100% { content: '...'; } }
  </style>
</head>
<body>
  <div class="header">
    <h1>💄 Marrie</h1>
    <p>Belleza suave · pedidos rápidos</p>
  </div>

  <div id="app" style="position:relative;z-index:1">
    <div id="tabs">Cargando categorías...</div>
    <div id="content"><div class="loading">Cargando productos</div></div>
  </div>

  <button id="cart-btn" title="Abrir carrito" style="display:none">
    <span id="cart-icon">🛒</span>
    <span id="cart-summary">Carrito</span>
    <span class="badge" id="cart-count">0</span>
  </button>

  <div id="cart-popup-overlay" style="display:none">
    <div id="cart-popup" role="dialog" aria-modal="true">
      <h3>✨ Confirmar pedido</h3>
      <div id="cart-items-container"></div>
      <div id="cart-total" style="margin-top:12px;font-weight:700"></div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:20px;flex-wrap:wrap">
        <button id="cart-close" class="small">Seguir comprando</button>
        <button id="cart-confirm" class="btn order">Enviar por WhatsApp 📱</button>
      </div>
    </div>
  </div>

  <!-- image modal -->
  <div id="img-modal-overlay" role="dialog" aria-hidden="true">
    <div id="img-modal">
      <button id="img-modal-close" class="small">✕ Cerrar</button>
      <img id="img-modal-img" alt="Imagen completa">
    </div>
  </div>

  <script>
    /*************************************************************************
     * Config
     **************************************************************************/
    const API_URL = "https://d.thepersonmrt.workers.dev/"; // tu worker
    const tabsEl = document.getElementById('tabs');
    const contentEl = document.getElementById('content');
    let lastProductsCache = []; // array de { row, sheetKey, data }
    let lastLoadedSheetKey = null;
    let availableSheetKeys = [];

    /*************************************************************************
     * Utilidades: safe extractores, escape, parse numeric
     **************************************************************************/
    function firstKeyValue(obj, keys){
      if (!obj) return undefined;
      const map = {};
      Object.keys(obj).forEach(k => map[k.toLowerCase()] = obj[k]);
      for (let key of keys){
        const v = map[key.toLowerCase()];
        if (v !== undefined && v !== null && String(v).trim() !== '') return v;
      }
      return undefined;
    }
    function escapeHtml(str){
      if(str === undefined || str === null) return '';
      return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }
    function parsePriceNumber(v){
      if (v === undefined || v === null) return 0;
      if (typeof v === 'number' && !isNaN(v)) return v;
      let s = String(v).trim();
      if (s === '') return 0;
      s = s.replace(/\s+/g, '');
      s = s.replace(/\./g, '');
      s = s.replace(/,/g, '.');
      s = s.replace(/[^0-9.\-]/g, '');
      const n = Number(s);
      return isNaN(n) ? 0 : n;
    }
    function fmtPrice(v){
      if (v===undefined || v===null) return '-';
      const s = String(v).trim();
      if (s === '') return '-';
      const n = parsePriceNumber(s);
      if (/^[\d\.\,]+$/.test(s)) {
        return Number(n).toLocaleString('de-DE');
      }
      return s;
    }

    /*************************************************************************
     * Simple cache (localStorage) with TTL para respuestas API (all y sheetKey)
     **************************************************************************/
    function cacheSet(key, value, ttlSec = 60){
      try {
        const obj = { ts: Date.now(), ttl: ttlSec*1000, value };
        localStorage.setItem('cache:'+key, JSON.stringify(obj));
      } catch(e){ /* noop */ }
    }
    function cacheGet(key){
      try {
        const raw = localStorage.getItem('cache:'+key);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(Date.now() - obj.ts > obj.ttl){ localStorage.removeItem('cache:'+key); return null; }
        return obj.value;
      } catch(e){ return null; }
    }

    /*************************************************************************
     * Lazy image loader: usamos IntersectionObserver para cargar imágenes
     **************************************************************************/
    const lazyObserver = new IntersectionObserver((entries)=>{
      entries.forEach(entry => {
        if(!entry.isIntersecting) return;
        const img = entry.target;
        const src = img.dataset && img.dataset.src;
        if(src){
          img.src = src;
          delete img.dataset.src;
        }
        lazyObserver.unobserve(img);
      });
    }, { rootMargin: '300px' });

    function proxiedUrl(raw){
      if(!raw || typeof raw !== 'string') return '';
      return API_URL + 'image-proxy?url=' + encodeURIComponent(raw);
    }

    function makeImgEl(raw, alt, className){
      const img = document.createElement('img');
      img.alt = alt || '';
      img.className = className || '';
      img.decoding = 'async';
      // lazy load via data-src + observer (so we can use placeholders)
      try {
        img.dataset.src = proxiedUrl(raw);
        img.loading = 'lazy';
        lazyObserver.observe(img);
      } catch(e){
        img.src = '';
      }
      img.onerror = () => { img.remove(); };
      return img;
    }

    /*************************************************************************
     * Carrito
     **************************************************************************/
    const WHATSAPP_NUMBER = '573207378992';
    let cart = JSON.parse(localStorage.getItem('shop_cart_v1') || '[]');

    const cartBtn = document.getElementById('cart-btn');
    const cartCountEl = document.getElementById('cart-count');
    const cartSummaryEl = document.getElementById('cart-summary');
    const cartOverlay = document.getElementById('cart-popup-overlay');
    const cartItemsContainer = document.getElementById('cart-items-container');
    const cartTotalEl = document.getElementById('cart-total');
    const cartCloseBtn = document.getElementById('cart-close');
    const cartConfirmBtn = document.getElementById('cart-confirm');

    function saveCart(){ localStorage.setItem('shop_cart_v1', JSON.stringify(cart)); }
    function cartItemKey(item){ return `${item.sheetKey}::${item.row}`; }

    function mapToAvailableSheetKey(input){
      if(!input) return null;
      const s = String(input).trim();
      if(availableSheetKeys && availableSheetKeys.length){
        const found = availableSheetKeys.find(k => String(k).toLowerCase() === s.toLowerCase());
        if(found) return found;
      }
      return s || null;
    }

    /*************************************************************************
     * Cache-aware find product in cache: usa sheetKey+row para evitar colisiones
     **************************************************************************/
    function findProductInCache(sheetKey, row){
      if(!Array.isArray(lastProductsCache)) return null;
      const targetSk = (sheetKey || '').toString().trim().toLowerCase();
      return lastProductsCache.find(pp => {
        const sk = (pp.sheetKey || (pp.data && (pp.data.Categoria || pp.data.categoria)) || '').toString().trim().toLowerCase();
        return String(pp.row) === String(row) && sk === targetSk;
      }) || null;
    }

    function getOriginalStock(sheetKey, row){
      // prioridad: dataset en DOM -> cache por sheetKey+row -> fallback row-only
      const card = Array.from(document.querySelectorAll('.card')).find(c => {
        const sk = (c.dataset.sheetKey || '').toString().trim().toLowerCase();
        const rrow = (c.dataset.row || '').toString();
        return sk === (sheetKey||'').toString().trim().toLowerCase() && rrow === (row||'').toString();
      });
      if (card && card.dataset.origStock !== undefined) return Number(card.dataset.origStock || 0);

      const p = findProductInCache(sheetKey, row);
      if (p){
        const d = p.data || {};
        const stock = firstKeyValue(d, ['stock','cantidad','Stock']) || d.Stock || 0;
        return Number(stock || 0);
      }

      // fallback: search by row only
      const p2 = (Array.isArray(lastProductsCache) && lastProductsCache.find(pp=>String(pp.row)===String(row))) || null;
      if(p2){
        const d = p2.data || {};
        const stock = firstKeyValue(d, ['stock','cantidad','Stock']) || 0;
        return Number(stock || 0);
      }
      return 0;
    }

    function getReservedQty(sheetKey, row){
      return cart.filter(i => (i.sheetKey||'').toString().trim().toLowerCase() === (sheetKey||'').toString().trim().toLowerCase() && String(i.row) === String(row)).reduce((s,i)=>s+Number(i.qty||0), 0);
    }

    function refreshCardStockDisplay(sheetKey, row){
      const skNorm = (sheetKey||'').toString().trim().toLowerCase();
      const cards = Array.from(document.querySelectorAll('.card')).filter(c => {
        const sk = (c.dataset.sheetKey || '').toString().trim().toLowerCase();
        const rrow = (c.dataset.row || '').toString();
        return sk === skNorm && rrow === (row||'').toString();
      });
      const origStock = getOriginalStock(sheetKey, row);
      const reserved = getReservedQty(sheetKey, row);
      const avail = Math.max(0, origStock - reserved);
      cards.forEach(card => {
        const stockSpan = card.querySelector('.stockval');
        if(stockSpan) stockSpan.innerText = avail;
        const orderBtn = card.querySelector('.order');
        if(avail <= 0){
          card.classList.add('out');
          if(orderBtn) orderBtn.disabled = true;
        } else {
          card.classList.remove('out');
          if(orderBtn) orderBtn.disabled = false;
        }
      });
    }

    function updateCartUI(){
      const count = cart.reduce((s,i)=>s+Number(i.qty||0),0);
      const total = cart.reduce((s,i)=> s + (parsePriceNumber(i._priceNum !== undefined ? i._priceNum : i.price) * Number(i.qty||0)), 0);
      cartCountEl.innerText = count;
      cartSummaryEl.innerText = count > 0 ? 'Carrito' : 'Carrito vacío';
      if(cartBtn) cartBtn.style.display = count > 0 ? 'flex' : 'none';
      if(cartBtn) cartBtn.title = count ? `${count} item(s) en carrito — Total $ ${Number(total).toLocaleString('de-DE')}` : 'Carrito vacío';
      saveCart();
    }

    /*************************************************************************
     * Actualización de stock en servidor
     * - decrement: usa action 'decrement' (tu AppsScript lo soporta)
     * - set: usa action 'set' para establecer una nueva cantidad
     **************************************************************************/
    async function updateStockOnServer_decrement(sheetKeyRaw, row, qty){
      if(!qty || qty <= 0) return;
      const mappedKey = mapToAvailableSheetKey(sheetKeyRaw);
      if(!mappedKey){
        console.warn('updateStockOnServer_decrement: sheetKey no reconocido:', sheetKeyRaw);
        return;
      }
      // Ejecutamos en serie para evitar race conditions en hoja (AppsScript simple)
      for(let i=0;i<qty;i++){
        try {
          const resp = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'decrement', sheetKey: mappedKey, row: String(row) })
          });
          const text = await resp.text().catch(()=>null);
          let json = null;
          try { json = text ? JSON.parse(text) : null; } catch(e){ json = null; }
          if(resp.ok && json && !json.error){
            const confirmedStock = (json.newStock !== undefined) ? Number(json.newStock) : undefined;
            if(confirmedStock !== undefined){
              document.querySelectorAll('.card').forEach(card=>{
                const csk = (card.dataset.sheetKey||'').toString().trim();
                const rw = card.dataset.row;
                if(String(rw) === String(row) && (csk.toLowerCase() === mappedKey.toLowerCase() || csk.toLowerCase() === sheetKeyRaw.toString().trim().toLowerCase())){
                  card.dataset.origStock = String(confirmedStock);
                }
              });
              refreshCardStockDisplay(mappedKey, row);
            }
            // continue
          } else {
            console.warn('Decrement fallo o respuesta inesperada:', resp.status, text);
            break;
          }
        } catch (err){
          console.warn('Decrement petición falló:', err);
          break;
        }
      }
    }

    async function updateStockOnServer_set(sheetKeyRaw, row, newStock){
      const mappedKey = mapToAvailableSheetKey(sheetKeyRaw) || sheetKeyRaw;
      try {
        const resp = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'set', sheetKey: mappedKey, row: String(row), value: String(newStock) })
        });
        const text = await resp.text().catch(()=>null);
        let json = null;
        try { json = text ? JSON.parse(text) : null; } catch(e){ json = null; }
        if(resp.ok && json && !json.error){
          const confirmedStock = (json.newStock !== undefined) ? Number(json.newStock) : Number(newStock);
          document.querySelectorAll('.card').forEach(card=>{
            const csk = (card.dataset.sheetKey||'').toString().trim();
            const rw = card.dataset.row;
            if(String(rw) === String(row) && (csk.toLowerCase() === mappedKey.toLowerCase() || csk.toLowerCase() === sheetKeyRaw.toString().trim().toLowerCase())){
              card.dataset.origStock = String(confirmedStock);
            }
          });
          refreshCardStockDisplay(mappedKey, row);
        } else {
          console.warn('updateStockOnServer_set: respuesta no OK', resp.status, text);
        }
      } catch (err) {
        console.warn('updateStockOnServer_set fallo:', err);
      }
    }

    /*************************************************************************
     * Añadir al carrito (optimistic UI) -> decrement remoto (serial)
     **************************************************************************/
    async function addToCart(card, qty){
      const sheetKey = card.dataset.sheetKey || lastLoadedSheetKey || 'UNKNOWN';
      const row = card.dataset.row;
      const name = card.querySelector('.name')?.innerText || 'Sin nombre';
      const priceRaw = card.dataset.price !== undefined ? card.dataset.price : (card.querySelector('.price')?.innerText || '');
      const priceNum = parsePriceNumber(priceRaw);
      const origStock = getOriginalStock(sheetKey, row);
      const reserved = getReservedQty(sheetKey,row);
      const available = Math.max(0, origStock - reserved);

      if(qty > available){
        alert('No hay suficiente stock disponible.');
        return;
      }

      const key = `${sheetKey}::${row}`;
      const existing = cart.find(i=>cartItemKey(i) === key);
      if(existing){
        existing.qty = Math.min(origStock, existing.qty + qty);
      } else {
        cart.push({ sheetKey, row, name, price: priceRaw, _priceNum: priceNum, qty });
      }

      // actualizar visual (reserva local)
      refreshCardStockDisplay(sheetKey,row);
      updateCartUI();

      // intentar decrementar en servidor (no bloqueante para UX)
      updateStockOnServer_decrement(sheetKey, row, qty).catch(e=>console.warn('updateStockOnServer_decrement error', e));

      // animación carrito
      if(cartBtn){
        cartBtn.style.animation = 'none';
        setTimeout(() => { cartBtn.style.animation = 'cartBounce 0.5s ease'; }, 10);
      }
    }

    /*************************************************************************
     * Popup carrito / eliminar items (cuando se elimina, aumentamos stock con 'set')
     **************************************************************************/
    function openCartPopup(){
      let html = '';
      if(cart.length === 0){
        cartItemsContainer.innerHTML = '<p style="text-align:center;color:#999">Carrito vacío</p>';
        cartTotalEl.innerHTML = '';
        cartOverlay.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        return;
      }

      cart.forEach((item, idx) => {
        const itemTotal = parsePriceNumber(item._priceNum !== undefined ? item._priceNum : item.price) * Number(item.qty||0);
        html += `
          <div class="cart-item">
            <span class="cart-item-name">${escapeHtml(item.name)}</span>
            <span class="cart-item-qty">x${item.qty}</span>
            <span class="cart-item-price">${Number(itemTotal).toLocaleString('de-DE')}</span>
            <button class="cart-item-remove" onclick="removeFromCart(${idx})">✕</button>
          </div>
        `;
      });

      cartItemsContainer.innerHTML = html || '<p style="text-align:center;color:#999">Carrito vacío</p>';

      const total = cart.reduce((s,i)=> s + (parsePriceNumber(i._priceNum !== undefined ? i._priceNum : i.price) * Number(i.qty||0)), 0);
      cartTotalEl.innerHTML = `💰 Total: <span style="color:var(--primary)">${Number(total).toLocaleString('de-DE')}</span>`;

      cartOverlay.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    function closeCartPopup(){ cartOverlay.style.display = 'none'; document.body.style.overflow = ''; }

    // Reemplaza removeFromCart por esta versión que además aumenta stock en el servidor
    function removeFromCart(idx){
      if(idx >= 0 && idx < cart.length){
        const item = cart[idx];

        // obtener stock "conocido" y calcular nuevo valor
        const currentOrig = Number(getOriginalStock(item.sheetKey, item.row) || 0);
        const removedQty = Number(item.qty || 0);
        const newStock = Math.max(0, currentOrig + removedQty);

        // eliminar del carrito
        cart.splice(idx, 1);

        // actualizar UI local
        refreshCardStockDisplay(item.sheetKey, item.row);
        updateCartUI();
        openCartPopup();

        // actualizar servidor (usamos 'set' para establecer el nuevo stock)
        updateStockOnServer_set(item.sheetKey, item.row, newStock);
      }
    }

    function sendToWhatsApp(){
      if(cart.length === 0){
        alert('El carrito está vacío');
        return;
      }
      let message = '✨ *Nuevo Pedido - Marrie* ✨\n\n';
      let total = 0;
      cart.forEach(item => {
        const itemTotal = parsePriceNumber(item._priceNum !== undefined ? item._priceNum : item.price) * Number(item.qty||0);
        total += itemTotal;
        message += `📦 *${item.name}*\n`;
        message += `   Cantidad: ${item.qty}\n`;
        message += `   Precio: ${Number(itemTotal).toLocaleString('de-DE')}\n\n`;
      });
      message += `💰 *TOTAL: ${Number(total).toLocaleString('de-DE')}*\n\n`;
      message += '📍 Por favor, confirma tu dirección de envío.';
      const url = `https://wa.me/${WHATSAPP_NUMBER}?text=${encodeURIComponent(message)}`;
      window.open(url, '_blank');
      // Clear cart after sending
      cart = [];
      updateCartUI();
      closeCartPopup();
    }

    cartBtn.addEventListener('click', openCartPopup);
    cartCloseBtn.addEventListener('click', closeCartPopup);
    cartConfirmBtn.addEventListener('click', sendToWhatsApp);
    cartOverlay.addEventListener('click', (e) => { if(e.target === cartOverlay) closeCartPopup(); });
    window.removeFromCart = removeFromCart;

    /*************************************************************************
     * Image modal
     **************************************************************************/
    const imgModalOverlay = document.getElementById('img-modal-overlay');
    const imgModalImg = document.getElementById('img-modal-img');
    const imgModalClose = document.getElementById('img-modal-close');
    function openImageModal(url, alt){
      if(!url) return;
      imgModalImg.src = proxiedUrl(url);
      imgModalImg.alt = alt || '';
      imgModalOverlay.style.display = 'flex';
      imgModalOverlay.setAttribute('aria-hidden','false');
      document.body.style.overflow = 'hidden';
    }
    function closeImageModal(){ imgModalOverlay.style.display = 'none'; imgModalOverlay.setAttribute('aria-hidden','true'); imgModalImg.src = ''; document.body.style.overflow = ''; }
    imgModalClose.addEventListener('click', closeImageModal);
    imgModalOverlay.addEventListener('click', (e)=>{ if(e.target === imgModalOverlay) closeImageModal(); });

    /*************************************************************************
     * Detalle on-demand: cuando el usuario abre la tarjeta (flip) pedimos
     * la hoja correspondiente si falta descripción / img / icono.
     * Esto acelera carga inicial y arregla el problema de "Todos".
     **************************************************************************/
    async function fetchSheetProductsCached(sheetKey){
      const mapped = mapToAvailableSheetKey(sheetKey) || sheetKey;
      const cacheKey = `sheet:${mapped}`;
      const cached = cacheGet(cacheKey);
      if(cached) return cached;
      try {
        const res = await fetch(API_URL + '?sheetKey=' + encodeURIComponent(mapped), { cache: 'no-store' });
        const json = await res.json();
        if(json && json.products){
          cacheSet(cacheKey, json.products, 60); // TTL 60s (ajustable)
          return json.products;
        }
      } catch(e){ console.warn('fetchSheetProductsCached error', e); }
      return [];
    }

    // ensureDetailFor: si la tarjeta no tiene descripcion/Img/Icono, intenta cargar detalle desde la sheet
    async function ensureDetailFor(sheetKey, row, cardElement){
      try {
        const cachedP = findProductInCache(sheetKey, row);
        if(cachedP && (cachedP.data && (cachedP.data.descripcion || cachedP.data.Descripcion || cachedP.data.description || cachedP.data.Img || cachedP.data.Icono))) {
          // ya tiene detalles
          return cachedP;
        }
        // pedir productos de la hoja
        const sheetProducts = await fetchSheetProductsCached(sheetKey);
        const found = (sheetProducts || []).find(pp => String(pp.row) === String(row));
        if(found){
          // actualizar lastProductsCache (merge o push)
          const idx = lastProductsCache.findIndex(pp => String(pp.row) === String(row) && (pp.sheetKey||'').toString().trim().toLowerCase() === (sheetKey||'').toString().trim().toLowerCase());
          const dataObj = found.data || found;
          if(idx >= 0){
            lastProductsCache[idx].data = Object.assign({}, lastProductsCache[idx].data || {}, dataObj);
          } else {
            lastProductsCache.push({ row: found.row, sheetKey: sheetKey, data: dataObj });
          }
          // actualizar DOM: description, back image, front icon, origStock
          if(cardElement){
            // desc-box
            const descBox = cardElement.querySelector('.desc-box');
            const descText = firstKeyValue(dataObj, ['descripcion','Descripcion','description','desc','nota','Nota']) || dataObj.descripcion || dataObj.Descripcion || '';
            if(descBox) descBox.innerHTML = escapeHtml(descText || 'Sin descripción disponible');
            // back image
            const backWrap = cardElement.querySelector('.back-image-wrap');
            const imgUrl = firstKeyValue(dataObj, ['img','Img','imagen','image','url','Imagen']) || dataObj.Img || '';
            if(backWrap){
              backWrap.innerHTML = '';
              if(imgUrl && /^(https?:)?\/\//i.test(imgUrl)){
                const imgLarge = makeImgEl(imgUrl, dataObj.Nombre || dataObj.name || '', 'back-image');
                imgLarge.addEventListener('click', (e)=>{ e.stopPropagation(); openImageModal(imgUrl, dataObj.Nombre || dataObj.name || ''); });
                backWrap.appendChild(imgLarge);
              } else {
                backWrap.innerHTML = `<div style="padding:30px;color:#bbb;font-size:3rem">🖼️</div>`;
              }
            }
            // front icon if missing
            const frontImgWrap = cardElement.querySelector('.front-image');
            const iconRaw = firstKeyValue(dataObj, ['icono','Icono','icon','emoji']) || dataObj.Icono || '';
            if(frontImgWrap && iconRaw){
              // clear any existing
              frontImgWrap.innerHTML = '';
              if(typeof iconRaw === 'string' && !/^(https?:)?\/\//i.test(iconRaw)){
                const span = document.createElement('div');
                span.style.fontSize = '52px';
                span.style.lineHeight = '1';
                span.innerText = iconRaw;
                frontImgWrap.appendChild(span);
              } else if (typeof iconRaw === 'string'){
                const smallImg = makeImgEl(iconRaw, dataObj.Nombre || '', 'product-img');
                frontImgWrap.appendChild(smallImg);
              }
            }
            // update origStock dataset
            const stockVal = Number(firstKeyValue(dataObj, ['stock','cantidad','Stock']) || dataObj.Stock || 0);
            if(cardElement.dataset) cardElement.dataset.origStock = String(stockVal);
            refreshCardStockDisplay(sheetKey, row);
          }
          return found;
        }
      } catch(e){
        console.warn('ensureDetailFor error', e);
      }
      return null;
    }

    /*************************************************************************
     * Render products (fast): usamos DocumentFragment para menor reflow.
     * Ahora renderProducts asume que cada producto puede no tener descripcion/Img.
     **************************************************************************/
    function renderProducts(products, sheetKey){
      if (!products || !products.length){
        if(contentEl) contentEl.innerHTML = '<div class="loading">No hay productos</div>';
        return;
      }
      const grid = document.createElement('div');
      grid.className='grid';
      const frag = document.createDocumentFragment();

      products.forEach((p, index)=>{
        const d = p.data || {};
        const name = firstKeyValue(d, ['name','nombre','producto','Nombre']) || d.Nombre || 'Sin nombre';
        const price = firstKeyValue(d, ['price','precio','Precio']) || d.Precio || '';
        const stock = Number(firstKeyValue(d, ['stock','cantidad','Stock']) || d.Stock || 0);

        const emojiIcon = firstKeyValue(d, ['icono','Icono','icon','emoji']) || d.Icono || '🛍️';
        const imgUrl = firstKeyValue(d, ['img','Img','imagen','image','url','Imagen']) || d.Img || '';

        const description = firstKeyValue(d, ['descripcion','Descripcion','description','desc','nota','Nota']) || d.descripcion || d.Descripcion || '';
        const productSheetKey = (p.sheetKey || d.Categoria || sheetKey || 'UNKNOWN').toString();

        // normalize cache entry
        const cacheEntry = { row: p.row, sheetKey: productSheetKey, data: d };
        // ensure lastProductsCache has this (replace same sheetKey+row)
        const existingIndex = lastProductsCache.findIndex(pp => String(pp.row) === String(p.row) && (pp.sheetKey||'').toString().trim().toLowerCase() === productSheetKey.toString().trim().toLowerCase());
        if(existingIndex >= 0) lastProductsCache[existingIndex] = cacheEntry;
        else lastProductsCache.push(cacheEntry);

        const cardWrap = document.createElement('div');
        cardWrap.className = 'card';
        cardWrap.dataset.origStock = String(stock);
        cardWrap.dataset.price = price;
        cardWrap.dataset.row = String(p.row);
        cardWrap.dataset.sheetKey = String(productSheetKey);
        cardWrap.style.setProperty('--card-index', index);

        const inner = document.createElement('div');
        inner.className = 'flip-inner';

        const front = document.createElement('div');
        front.className = 'face front';
        front.innerHTML = `
          <div style="position:relative;padding:12px;">
            <button class="eye-toggle" aria-pressed="false" title="Ver imagen y descripción" type="button" aria-label="Ver imagen y descripción">
              <svg class="eye-open" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M2 12s4-7 10-7 10 7 10 7-4 7-10 7S2 12 2 12z" stroke="#ff6b9d" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <circle cx="12" cy="12" r="3" stroke="#ff6b9d" stroke-width="2"/>
              </svg>
            </button>

            <div class="front-image"></div>

            <div class="meta">
              <div class="name">${escapeHtml(name)}</div>
              <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px">
                <div class="price">$ ${fmtPrice(price)}</div>
                <div class="stock">Stock: <span class="stockval">${Math.max(0, stock - getReservedQty(productSheetKey, p.row))}</span></div>
              </div>
            </div>
          </div>

          <div style="padding:0 16px 16px">
            <div class="actions">
              <button class="small minus">−</button>
              <span class="qty">1</span>
              <button class="small plus">+</button>
              <button class="btn order" ${stock<=0?'disabled':''}>Pedir</button>
            </div>
          </div>
        `;

        const back = document.createElement('div');
        back.className = 'face back';
        back.innerHTML = `
          <div style="position:relative;padding:12px">
            <button class="eye-toggle" aria-pressed="true" title="Volver" type="button" aria-label="Volver">
              <svg class="eye-closed" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M19 12H5" stroke="#ff6b9d" stroke-width="2" stroke-linecap="round"/>
                <path d="M12 19l-7-7 7-7" stroke="#ff6b9d" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>

          <div class="back-image-wrap"></div>
          <div style="padding:12px">
            <div class="desc-box">${escapeHtml(description || 'Sin descripción disponible')}</div>
          </div>

          <div style="height:12px"></div>
        `;

        inner.appendChild(front);
        inner.appendChild(back);
        cardWrap.appendChild(inner);
        frag.appendChild(cardWrap);

        // populate front circle with emojiIcon (if it's not a URL)
        const frontImageWrap = front.querySelector('.front-image');
        if (emojiIcon && typeof emojiIcon === 'string' && !/^(https?:)?\/\//i.test(emojiIcon)) {
          const span = document.createElement('div');
          span.style.fontSize = '52px';
          span.style.lineHeight = '1';
          span.innerText = emojiIcon;
          frontImageWrap.appendChild(span);
        } else if (emojiIcon && typeof emojiIcon === 'string') {
          const smallImg = makeImgEl(emojiIcon, name, 'product-img');
          frontImageWrap.appendChild(smallImg);
        }

        // back image: only from imgUrl (lazy)
        const backImageWrap = back.querySelector('.back-image-wrap');
        if (imgUrl && typeof imgUrl === 'string' && /^(https?:)?\/\//i.test(imgUrl)) {
          const imgLarge = makeImgEl(imgUrl, name, 'back-image');
          imgLarge.addEventListener('click', (e)=>{ e.stopPropagation(); openImageModal(imgUrl, name); });
          backImageWrap.appendChild(imgLarge);
        } else {
          backImageWrap.innerHTML = `<div style="padding:30px;color:#bbb;font-size:3rem">🖼️</div>`;
        }

        // toggles
        const eyeFront = front.querySelector('.eye-toggle');
        const eyeBack = back.querySelector('.eye-toggle');

        // async showBack: ensure detail loaded before showing back content
        async function showBack(){
          // try to fetch detail only if description/img/icon missing
          await ensureDetailFor(productSheetKey, p.row, cardWrap);
          inner.classList.add('flipped');
        }
        function showFront(){ inner.classList.remove('flipped'); }

        eyeFront.addEventListener('click', (e)=>{ e.stopPropagation(); showBack(); });
        eyeBack.addEventListener('click', (e)=>{ e.stopPropagation(); showFront(); });

        // close back if click outside content area inside the card (keeps layout stable)
        cardWrap.addEventListener('click', (ev) => {
          if (inner.classList.contains('flipped')) {
            const targetIsInsideBack = back.contains(ev.target);
            if (!targetIsInsideBack) showFront();
          }
        });

        // quantity controls
        const minusBtns = cardWrap.querySelectorAll('.minus');
        const plusBtns = cardWrap.querySelectorAll('.plus');
        const qtySpans = cardWrap.querySelectorAll('.qty');
        minusBtns.forEach(btn => btn.addEventListener('click', (e)=>{
          e.stopPropagation();
          const current = Number(qtySpans[0].innerText || '1');
          if(current > 1){ qtySpans.forEach(s=>s.innerText = current - 1); }
        }));
        plusBtns.forEach(btn => btn.addEventListener('click', (e)=>{
          e.stopPropagation();
          const orig = getOriginalStock(cardWrap.dataset.sheetKey, cardWrap.dataset.row);
          const current = Number(qtySpans[0].innerText || '1');
          if(current < Math.max(0, orig - getReservedQty(cardWrap.dataset.sheetKey, cardWrap.dataset.row))){
            qtySpans.forEach(s=>s.innerText = current + 1);
          }
        }));

        // order buttons (only front)
        const orderBtns = cardWrap.querySelectorAll('.order');
        orderBtns.forEach(btn => btn.addEventListener('click', (e)=>{
          e.stopPropagation();
          const qty = Number(cardWrap.querySelector('.qty').innerText || '1');
          addToCart(cardWrap, qty);
        }));

      });

      grid.appendChild(frag);
      if(contentEl){ contentEl.innerHTML=''; contentEl.appendChild(grid); }
    }

    /*************************************************************************
     * Cargar categorías y pestañas
     **************************************************************************/
    async function loadCategories(){
      try {
        // cache simple para root (lista de sheets)
        const cacheKey = 'root_sheets';
        let data = cacheGet(cacheKey);
        if(!data){
          const r = await fetch(API_URL, {cache:'no-store'});
          data = await r.json();
          cacheSet(cacheKey, data, 60);
        }
        if (!data.sheets) throw new Error("Respuesta inválida");
        availableSheetKeys = (data.sheets || []).map(s => s.key).filter(Boolean);
        renderTabs(data.sheets);
      } catch(err){
        if(tabsEl) tabsEl.innerHTML = 'Error cargando categorías';
        console.error(err);
      }
    }

    function renderTabs(sheets){
      if(!tabsEl) return;
      tabsEl.innerHTML = '';
      const allBtn = document.createElement('button');
      allBtn.className = 'tab active';
      allBtn.innerText = "✨ Todos";
      allBtn.onclick = () => {
        document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
        allBtn.classList.add('active');
        loadProductsAll();
      };
      tabsEl.appendChild(allBtn);

      sheets.forEach((s)=>{
        const btn = document.createElement('button');
        btn.className = 'tab';
        btn.innerText = s.key;
        btn.dataset.key = s.key;
        btn.onclick = ()=> {
          document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
          btn.classList.add('active');
          loadProductsFor(s.key);
        };
        tabsEl.appendChild(btn);
      });

      loadProductsAll();
    }

    /*************************************************************************
     * Cargar productos por sheetKey (detalle completo) - usa cache TTL
     **************************************************************************/
    async function loadProductsFor(sheetKey){
      lastLoadedSheetKey = sheetKey;
      if(contentEl) contentEl.innerHTML = '<div class="loading">Cargando productos</div>';
      try {
        const cacheKey = `sheet:${sheetKey}`;
        let data = cacheGet(cacheKey);
        if(!data){
          const r = await fetch(API_URL+'?sheetKey='+encodeURIComponent(sheetKey), {cache:'no-store'});
          data = await r.json();
          cacheSet(cacheKey, data, 60);
        }
        if (data.error){ contentEl.innerHTML='Error: '+data.message; return; }
        const products = (data.products || []).map(p=> {
          if(!p.sheetKey) p.sheetKey = sheetKey;
          return p;
        });
        // normalize cache entries
        lastProductsCache = products.map(p => ({ row: p.row, sheetKey: p.sheetKey || sheetKey, data: p.data || {} }));
        renderProducts(products, sheetKey);
      } catch(err){ console.error(err); if(contentEl) contentEl.innerHTML='<div class="loading">Error cargando productos</div>'; }
    }

    /*************************************************************************
     * loadProductsAll: fetch rápido (all=1), render rápido sin pedir detalle.
     * Las descripciones/imagenes faltantes se pedirán en ensureDetailFor al flip.
     **************************************************************************/
    async function loadProductsAll(){
      lastLoadedSheetKey = "ALL";
      if(contentEl) contentEl.innerHTML = '<div class="loading">Cargando todos los productos</div>';
      try {
        const cacheKey = 'all_products';
        let data = cacheGet(cacheKey);
        if(!data){
          const r = await fetch(API_URL+'?all=1', {cache:'no-store'});
          data = await r.json();
          cacheSet(cacheKey, data, 30); // TTL corto
        }
        if (data.error){ contentEl.innerHTML='Error: '+data.message; return; }
        let products = data.products || [];

        // ensure each product has a sensible sheetKey
        products = products.map(p=>{
          p.data = p.data || {};
          if(!p.data.Categoria) p.data.Categoria = p.data.Categoria || p.data.categoria || 'UNKNOWN';
          p.sheetKey = p.sheetKey || p.data.Categoria || p.data.Categoria || 'UNKNOWN';
          return p;
        });

        // populate lastProductsCache minimal
        lastProductsCache = products.map(p => ({ row: p.row, sheetKey: p.sheetKey, data: p.data || {} }));

        // Render quickly (descripciones se cargarán on-demand)
        renderProducts(lastProductsCache.map(p=>({ row: p.row, data: p.data, sheetKey: p.sheetKey })), "ALL");
      } catch(err){
        console.error(err);
        if(contentEl) contentEl.innerHTML = '<div class="loading">Error cargando productos</div>';
      }
    }

    /*************************************************************************
     * Init
     **************************************************************************/
    loadCategories();
    updateCartUI();
  </script>
</body>
</html>
