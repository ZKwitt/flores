<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catálogo — Marrie</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --bg1: #fef6fa;
      --bg2: #f5f0ff;
      --primary: #ff6b9d;
      --secondary: #c66fbc;
      --accent: #66d9ef;
      --muted: #8b7f99;
      --card-bg: rgba(255,255,255,0.98);
      --soft-shadow: 0 20px 60px rgba(150,100,200,0.08);
      --hover-shadow: 0 25px 70px rgba(150,100,200,0.12);
      --gradient1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient3: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      --gradient-soft: linear-gradient(135deg, rgba(255,107,157,0.1) 0%, rgba(102,217,239,0.1) 100%);
      --ring-color: rgba(255,107,157,0.18);
    }

    body{
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background:
        radial-gradient(ellipse at top left, rgba(255,182,193,0.3) 0%, transparent 50%),
        radial-gradient(ellipse at top right, rgba(221,160,221,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at bottom left, rgba(176,224,230,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(255,218,185,0.2) 0%, transparent 50%),
        linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
      min-height:100vh;
      padding:36px;
      color:#2a2438;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* header */
    .header{ text-align:center; margin-bottom:30px; position:relative; z-index:1; animation: fadeInDown 0.8s ease; }
    .header h1{ font-size:2.8rem; font-weight:900; background: var(--gradient2); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; margin-bottom:8px; letter-spacing:-0.02em; filter: drop-shadow(2px 2px 20px rgba(255,107,157,0.3)); }
    .header p{ color:var(--muted); font-size:1.1rem; font-weight:500; letter-spacing:0.5px; }
    @keyframes fadeInDown { from { opacity:0; transform:translateY(-20px); } to { opacity:1; transform:translateY(0); } }

    /* TABS - keep existing look but fix seam with pseudo element under the button when active */
    #tabs{ display:flex; flex-wrap:wrap; gap:14px; justify-content:center; margin:20px 0 30px; z-index:1; position:relative; animation: fadeIn 1s ease 0.3s both; overflow:visible; }

    .tab{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:10px 20px;
      border-radius:999px;
      background: var(--card-bg);
      color:#5a4a6b;
      font-weight:600;
      cursor:pointer;
      transition:all 0.28s cubic-bezier(0.4,0,0.2,1);
      box-shadow:0 4px 15px rgba(0,0,0,0.05);
      border:2px solid rgba(255,107,157,0.10); /* preserve original border look */
      z-index:1;
      overflow:visible; /* important so pseudo can expand outside */
      background-clip: padding-box;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      transform: translateZ(0);
    }

    /* keep soft overlay in hover (behind content) */
    .tab::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      background: var(--gradient-soft);
      opacity:0;
      transition:opacity .25s;
      z-index:0; /* behind text/content */
      pointer-events:none;
    }
    .tab:hover{ transform:translateY(-3px); box-shadow:0 8px 25px rgba(255,107,157,0.15); border-color:rgba(255,107,157,0.3); }
    .tab:hover::before{ opacity:1; }

    /* NEW: pseudo ::after used for active to draw gradient underneath and slightly outside the button,
       this covers the seam caused by border while keeping the border in default state.
       We only show it when .tab.active by using opacity. */
    .tab::after{
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 999px;
      z-index: -1; /* behind the button content */
      pointer-events: none;
      transition: opacity .22s, transform .22s;
      opacity: 0;
      /* default: no visual gradient here */
      box-shadow: 0 0 0 0 rgba(0,0,0,0);
    }

    .tab.active{
      color: #fff;
      transform: translateY(-3px) scale(1.03);
      border-color: transparent; /* make border transparent so it doesn't cut gradient */
      box-shadow: 0 10px 30px rgba(255,107,157,0.25);
      z-index: 2;
    }

    /* When active, paint the ::after with the desired gradient and expand slightly outside
       so it visually envelops the border area (removes seam). */
    .tab.active::after{
      opacity: 1;
      /* expand slightly to hide any seam from the border (negative inset) */
      inset: -3px; /* controls how far the gradient extends beyond the button - tweak if needed */
      background: var(--gradient2);
      transform: scale(1);
      filter: blur(0.15px); /* tiny blur sometimes hides sub-pixel seam in some browsers */
    }

    .tab:focus-visible{ outline: 3px solid rgba(102,217,239,0.25); outline-offset:4px; }

    /* small buttons: same approach — preserve border normally, use ::after to draw active gradient behind */
    .small{
      position:relative;
      width:36px;
      height:36px;
      border-radius:12px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(135deg, #fff, rgba(255,107,157,0.05));
      color:#5a4a6b;
      font-weight:700;
      border:2px solid rgba(255,107,157,0.15);
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      transition: transform .18s, box-shadow .18s;
      overflow:visible;
      background-clip: padding-box;
      z-index:1;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .small::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:12px;
      z-index:-1;
      pointer-events:none;
      transition: opacity .18s;
      opacity:0;
    }
    .small:hover{ transform:scale(1.08); border-color:rgba(255,107,157,0.25); box-shadow:0 6px 15px rgba(255,107,157,0.12); }
    .small.selected, .small:active, .small:focus-visible{
      color:#fff;
      border-color: transparent;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 10px 25px rgba(255,107,157,0.25);
    }
    .small.selected::after{
      opacity:1;
      inset: -2px;
      background: var(--gradient2);
      filter: blur(0.12px);
    }

    /* order button: ensure gradient covers completely (no border) */
    .btn.order{
      background: var(--gradient2);
      color:#fff;
      padding:12px 24px;
      border-radius:999px;
      border:0;
      cursor:pointer;
      font-weight:700;
      box-shadow:0 8px 20px rgba(255,107,157,0.25);
      transition:transform .18s, box-shadow .18s;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .btn.order:hover{ transform: translateY(-2px); box-shadow:0 12px 30px rgba(255,107,157,0.35); }

    /* rest kept intact (cards, meta) - copy your original rules below exactly as you had them */
    #content { max-width:1200px; margin:0 auto; min-height:160px; text-align:center; z-index:1; animation: fadeInUp 0.8s ease 0.5s both; }
    @keyframes fadeInUp { from { opacity:0; transform:translateY(20px); } to { opacity:1; transform:translateY(0); } }
    .loading{ text-align:center; padding:60px 0; color:var(--muted); font-weight:600; font-size:1.1rem; }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(320px,1fr)); gap:25px; align-items:start; }
    .card{ position:relative; perspective:1000px; animation: cardEntry 0.6s ease both; animation-delay: calc(var(--card-index, 0) * 0.05s); transition: opacity 0.25s ease, transform 0.2s ease; }
    @keyframes cardEntry { from{opacity:0;transform:translateY(30px) scale(0.95)} to{opacity:1;transform:translateY(0) scale(1)} }
    .flip-inner{ position:relative; width:100%; min-height:440px; border-radius:24px; overflow:visible; transition:none; }
    .face{ position:absolute; inset:0; border-radius:24px; overflow:hidden; box-shadow: var(--soft-shadow); transition: all 0.4s cubic-bezier(0.4,0,0.2,1); background: var(--card-bg); border:1px solid rgba(255,255,255,0.8); display:flex; flex-direction:column; justify-content:space-between; padding-bottom:16px; backface-visibility:hidden; backdrop-filter: blur(10px); }
    .face::before{ content:''; position:absolute; inset:0; background: var(--gradient-soft); opacity:0.3; pointer-events:none; border-radius:24px; }
    .face.front{ opacity:1; transform: translateY(0) rotateX(0); visibility:visible; z-index:2; position:relative; }
    .face.back{ opacity:0; transform: translateY(10px) rotateX(-10deg); visibility:hidden; z-index:1; }
    .flip-inner.flipped .face.front{ opacity:0; transform: translateY(-10px) rotateX(10deg); visibility:hidden; z-index:1; }
    .flip-inner.flipped .face.back{ opacity:1; transform: translateY(0) rotateX(0); visibility:visible; z-index:2; }

    /* rest of your CSS (cart, modals etc.) — insert here unchanged from your original */

    /* responsive */
    @media (max-width:768px) { .header h1 { font-size: 2.2rem; } .grid { grid-template-columns: repeat(auto-fill, minmax(280px,1fr)); gap: 20px; } #cart-btn { bottom: 20px; right: 20px; padding: 14px 20px; } }
    @media (max-width:520px) { body { padding: 20px; } .header h1 { font-size: 1.8rem; } .grid { grid-template-columns: 1fr; } .front-image { width: 110px; height: 110px; } .flip-inner { min-height: 400px; } .back-image-wrap { height: 200px; } #cart-popup { padding: 20px; } #cart-btn { bottom: 15px; right: 15px; padding: 12px 18px; font-size: 0.9rem; } }
    /* loading dots */
    .loading::after { content: '...'; animation: dots 1.5s steps(4,end) infinite; }
    @keyframes dots { 0%,20%{content:'.'} 40%{content:'..'} 60%,100%{content:'...'} }

  </style>
</head>
<body>
  <div class="header">
    <h1>💄 Marrie</h1>
    <p>Belleza suave · Calidad que perdura</p>
  </div>

  <div id="app" style="position:relative;z-index:1">
    <div id="tabs">Cargando categorías...</div>
    <div id="content"><div class="loading">Cargando productos</div></div>
  </div>

  <button id="cart-btn" title="Abrir carrito" style="display:none">
    <span id="cart-icon">🛒</span>
    <span id="cart-summary">Carrito</span>
    <span class="badge" id="cart-count">0</span>
  </button>

  <div id="cart-popup-overlay" style="display:none">
    <div id="cart-popup" role="dialog" aria-modal="true">
      <h3>✨ Confirmar pedido</h3>
      <div id="cart-items-container"></div>
      <div id="cart-total" style="margin-top:12px;font-weight:700"></div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:20px;flex-wrap:wrap">
        <button id="cart-close" class="small">✕</button>
        <button id="cart-confirm" class="btn order">Enviar por WhatsApp 📱</button>
      </div>
    </div>
  </div>

  <!-- image modal -->
  <div id="img-modal-overlay" role="dialog" aria-hidden="true">
    <div id="img-modal">
      <button id="img-modal-close" class="small">✕ Cerrar</button>
      <img id="img-modal-img" alt="Imagen completa">
    </div>
  </div>
  <script>
  const API_URL = "https://d.thepersonmrt.workers.dev/"; // tu worker
  const tabsEl = document.getElementById('tabs');
  const contentEl = document.getElementById('content');
  let lastProductsCache = []; // almacenará productos (cada objeto incluye .sheetKey y .row)
  let lastLoadedSheetKey = null;
  let availableSheetKeys = []; // keys válidas devueltas por GET /

  (function(){
    // create emoji decorative background (sin cambios funcionales)
    const emojis = ['💄','💋','🌸','✨','🩷','🌺'];
    const count = 14;
    const container = document.createElement('div');
    container.className = 'emoji-bg';
    for(let i=0;i<count;i++){
      const s = document.createElement('span');
      s.className = 'emoji';
      s.textContent = emojis[i % emojis.length];
      const size = Math.round((Math.random()*36)+20);
      s.style.fontSize = size + 'px';
      s.style.left = (Math.random()*100) + '%';
      s.style.top = (Math.random()*100) + '%';
      s.style.opacity = (Math.random()*0.06) + 0.03;
      s.style.animationDuration = (18 + Math.random()*32) + 's';
      s.style.animationDelay = (-Math.random()*20) + 's';
      s.style.transform = 'translate3d(0,0,0)';
      s.style.zIndex = '0';
      container.appendChild(s);
    }
    document.body.appendChild(container);

    // visual helpers
    document.addEventListener('click', function(e){
      if(e.target.matches('.tab')){
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
      }
      if(e.target.matches('.small')){
        e.target.classList.toggle('selected');
      }
    });

    const cartClose = document.getElementById('cart-close');
    if(cartClose) cartClose.setAttribute('aria-label','Cerrar carrito');
    document.addEventListener('keydown', function(e){ if(e.key === 'Tab') document.documentElement.classList.add('kbd'); });
    window.addEventListener('resize', function(){
      const els = document.querySelectorAll('.emoji-bg .emoji');
      els.forEach(el => { if(Math.random() < 0.35){ el.style.left = (Math.random()*100) + '%'; el.style.top = (Math.random()*100) + '%'; } });
    });
  })();

  /* ---------- utilidades ---------- */
  function firstKeyValue(obj, keys){
    if (!obj) return undefined;
    const map = {};
    Object.keys(obj).forEach(k => map[k.toLowerCase()] = obj[k]);
    for (let key of keys){
      const v = map[key.toLowerCase()];
      if (v !== undefined && v !== null && String(v).trim() !== '') return v;
    }
    return undefined;
  }

  function fmtPrice(v){
    if (v===undefined || v===null) return '-';
    const s = String(v).trim();
    if (s === '') return '-';
    const n = parsePriceNumber(s);
    if (/^[\d\.\,]+$/.test(s)) {
      return Number(n).toLocaleString('de-DE');
    }
    return s;
  }

  function parsePriceNumber(v){
    if (v === undefined || v === null) return 0;
    if (typeof v === 'number' && !isNaN(v)) return v;
    let s = String(v).trim();
    if (s === '') return 0;
    s = s.replace(/\s+/g, '');
    s = s.replace(/\./g, '');
    s = s.replace(/,/g, '.');
    s = s.replace(/[^0-9.\-]/g, '');
    const n = Number(s);
    return isNaN(n) ? 0 : n;
  }

  /* ---------- carrito ---------- */
  const WHATSAPP_NUMBER = '573207378992';
  let cart = JSON.parse(localStorage.getItem('shop_cart_v1') || '[]');

  const cartBtn = document.getElementById('cart-btn');
  const cartCountEl = document.getElementById('cart-count');
  const cartSummaryEl = document.getElementById('cart-summary');
  const cartOverlay = document.getElementById('cart-popup-overlay');
  const cartItemsContainer = document.getElementById('cart-items-container');
  const cartTotalEl = document.getElementById('cart-total');
  const cartCloseBtn = document.getElementById('cart-close');
  const cartConfirmBtn = document.getElementById('cart-confirm');

  function saveCart(){ localStorage.setItem('shop_cart_v1', JSON.stringify(cart)); }
  function cartItemKey(item){ return `${item.sheetKey}::${item.row}`; }

  function findProductInCache(sheetKey, row){
    if(!Array.isArray(lastProductsCache)) return null;
    const targetSk = (sheetKey || '').toString().trim();
    return lastProductsCache.find(pp => {
      const sk = (pp.sheetKey || (pp.data && (pp.data.Categoria || pp.data.categoria)) || '').toString().trim();
      return String(pp.row) === String(row) && sk.toString().trim().toLowerCase() === targetSk.toLowerCase();
    }) || null;
  }

  function getOriginalStock(sheetKey, row){
    const card = Array.from(document.querySelectorAll('.card')).find(c => {
      const sk = (c.dataset.sheetKey || c.getAttribute('data-sheet-key') || '').toString();
      const rrow = (c.dataset.row || c.getAttribute('data-row') || '').toString();
      return sk.toString().trim().toLowerCase() === (sheetKey||'').toString().trim().toLowerCase() && rrow === (row||'').toString();
    });
    if (card && card.dataset.origStock !== undefined) return Number(card.dataset.origStock || 0);
    const p = findProductInCache(sheetKey, row);
    if (p){
      const d = p.data || {};
      const stock = firstKeyValue(d, ['stock','cantidad','Stock']) || d.Stock || 0;
      return Number(stock || 0);
    }
    const p2 = (Array.isArray(lastProductsCache) && lastProductsCache.find(pp=>String(pp.row)===String(row))) || null;
    if(p2){
      const d = p2.data || {};
      const stock = firstKeyValue(d, ['stock','cantidad','Stock']) || 0;
      return Number(stock || 0);
    }
    return 0;
  }

  function getReservedQty(sheetKey, row){
    return cart.filter(i => (i.sheetKey||'').toString().trim().toLowerCase() === (sheetKey||'').toString().trim().toLowerCase() && String(i.row) === String(row)).reduce((s,i)=>s+Number(i.qty||0), 0);
  }

  function refreshCardStockDisplay(sheetKey, row){
    const cards = Array.from(document.querySelectorAll('.card')).filter(c => {
      const sk = (c.dataset.sheetKey || c.getAttribute('data-sheet-key') || '').toString().trim().toLowerCase();
      const rrow = (c.dataset.row || c.getAttribute('data-row') || '').toString();
      return sk === (sheetKey||'').toString().trim().toLowerCase() && rrow === (row||'').toString();
    });
    const origStock = getOriginalStock(sheetKey, row);
    const reserved = getReservedQty(sheetKey, row);
    const avail = Math.max(0, origStock - reserved);
    cards.forEach(card => {
      const stockSpan = card.querySelector('.stockval');
      if(stockSpan) stockSpan.innerText = avail;
      const orderBtn = card.querySelector('.order');
      if(avail <= 0){
        card.classList.add('out');
        card.style.opacity = '0.45';
        if(orderBtn) orderBtn.disabled = true;
      } else {
        card.classList.remove('out');
        card.style.opacity = '';
        if(orderBtn) orderBtn.disabled = false;
      }
    });
  }

  function updateCartUI(){
    const count = cart.reduce((s,i)=>s+Number(i.qty||0),0);
    const total = cart.reduce((s,i)=> s + (parsePriceNumber(i._priceNum !== undefined ? i._priceNum : i.price) * Number(i.qty||0)), 0);
    cartCountEl.innerText = count;
    cartSummaryEl.innerText = count > 0 ? 'Carrito' : 'Carrito vacío';
    if(cartBtn) cartBtn.style.display = count > 0 ? 'flex' : 'none';
    if(cartBtn) cartBtn.title = count ? `${count} item(s) en carrito — Total $ ${Number(total).toLocaleString('de-DE')}` : 'Carrito vacío';
    saveCart();
  }

  /* ---------- sync stock con servidor (decrement/set/increase) ---------- */
  function mapToAvailableSheetKey(input){
    if(!input) return null;
    const s = String(input).trim();
    if(availableSheetKeys && availableSheetKeys.length){
      const found = availableSheetKeys.find(k => String(k).toLowerCase() === s.toLowerCase());
      if(found) return found;
    }
    return s || null;
  }

  async function fetchServerStock(sheetKeyRaw, row){
    try {
      const mappedKey = mapToAvailableSheetKey(sheetKeyRaw) || sheetKeyRaw;
      if(!mappedKey) return null;
      const resp = await fetch(API_URL + '?sheetKey=' + encodeURIComponent(mappedKey), { cache: 'no-store' });
      if(!resp.ok) return null;
      const json = await resp.json().catch(()=>null);
      if(!json || !Array.isArray(json.products)) return null;
      const found = json.products.find(p => String(p.row) === String(row));
      if(!found) return null;
      const stockVal = firstKeyValue(found.data || {}, ['stock','cantidad','Stock']) || found.data && (found.data.Stock || found.data.cantidad) || 0;
      return Number(stockVal || 0);
    } catch (err) {
      console.warn('fetchServerStock error', err);
      return null;
    }
  }

  // Reconciliación: cuando el servidor responde con newStock, guardamos origStock = newStock + reservedLocal
  async function updateStockOnServer_decrement(sheetKeyRaw, row, qty){
    if(!qty || qty <= 0) return;
    const mappedKey = mapToAvailableSheetKey(sheetKeyRaw);
    if(!mappedKey){
      console.warn('updateStockOnServer_decrement: sheetKey no reconocido, no se enviará petición:', sheetKeyRaw);
      return;
    }

    for(let i=0;i<qty;i++){
      try {
        const resp = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'decrement', sheetKey: mappedKey, row: String(row) })
        });
        const text = await resp.text().catch(()=>null);
        let json = null;
        try { json = text ? JSON.parse(text) : null; } catch(e){ json = null; }

        if(resp.ok && json && !json.error){
          const confirmedStock = (json.newStock !== undefined) ? Number(json.newStock) : undefined;
          console.debug('server newStock (decrement)', { sheetKey: mappedKey, row, confirmedStock });
          if(confirmedStock !== undefined){
            const reservedLocal = getReservedQty(mappedKey, row);
            document.querySelectorAll('.card').forEach(card=>{
              const csk = (card.dataset.sheetKey||'').toString().trim().toLowerCase();
              const rw = card.dataset.row;
              if(String(rw) === String(row) && (csk.toLowerCase() === mappedKey.toLowerCase() || csk.toLowerCase() === sheetKeyRaw.toString().trim().toLowerCase())){
                // setear origStock = server + reservedLocal (reconciliación)
                card.dataset.origStock = String(Math.max(0, confirmedStock + reservedLocal));
              }
            });
            refreshCardStockDisplay(mappedKey, row);
          }
        } else {
          console.warn('Decrement fallo o respuesta inesperada:', resp.status, text);
          break;
        }
      } catch (err){
        console.warn('Decrement petición falló:', err);
        break;
      }
    }
  }

  async function updateStockOnServer_set(sheetKeyRaw, row, newStock){
    const mappedKey = mapToAvailableSheetKey(sheetKeyRaw) || sheetKeyRaw;
    try {
      const resp = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'set', sheetKey: mappedKey, row: String(row), value: String(newStock) })
      });

      const text = await resp.text().catch(()=>null);
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch(e){ json = null; }

      if(resp.ok && json && !json.error){
        const confirmedStock = (json.newStock !== undefined) ? Number(json.newStock) : Number(newStock);
        console.debug('server newStock (set)', { sheetKey: mappedKey, row, confirmedStock });
        const reservedLocal = getReservedQty(mappedKey, row);
        document.querySelectorAll('.card').forEach(card=>{
          const csk = (card.dataset.sheetKey||'').toString().trim().toLowerCase();
          const rw = card.dataset.row;
          if(String(rw) === String(row) && (csk.toLowerCase() === mappedKey.toLowerCase() || csk.toLowerCase() === sheetKeyRaw.toString().trim().toLowerCase())){
            card.dataset.origStock = String(Math.max(0, confirmedStock + reservedLocal));
          }
        });
        refreshCardStockDisplay(mappedKey, row);
      } else {
        console.warn('updateStockOnServer_set: respuesta no OK', resp.status, text);
      }
    } catch (err) {
      console.warn('updateStockOnServer_set fallo:', err);
    }
  }

  async function updateStockOnServer_increaseViaSet(sheetKeyRaw, row, delta){
    if(!delta || delta <= 0) return;
    const mappedKey = mapToAvailableSheetKey(sheetKeyRaw) || sheetKeyRaw;
    if(!mappedKey){
      console.warn('No sheetKey mapeable a availableSheetKeys, abortando increase/set:', sheetKeyRaw);
      return;
    }

    try {
      const serverStock = await fetchServerStock(mappedKey, row);
      const baseStock = (serverStock !== null && serverStock !== undefined) ? Number(serverStock) : Number(getOriginalStock(mappedKey, row) || 0);
      const newStock = Math.max(0, baseStock + Number(delta));
      await updateStockOnServer_set(mappedKey, row, newStock);
    } catch (err){
      console.warn('updateStockOnServer_increaseViaSet error', err);
    }
  }

  /* ---------- addToCart / removeFromCart (sin modificar dataset.origStock al push) ---------- */
  async function addToCart(card, qty){
    const sheetKey = (card && card.dataset.sheetKey) || lastLoadedSheetKey || 'UNKNOWN';
    const row = card && card.dataset.row;
    const name = card?.querySelector('.name')?.innerText || 'Sin nombre';
    const priceRaw = card?.dataset.price !== undefined ? card.dataset.price : (card?.querySelector('.price')?.innerText || '');
    const priceNum = parsePriceNumber(priceRaw);
    const origStock = getOriginalStock(sheetKey, row);
    const reserved = getReservedQty(sheetKey,row);
    const available = Math.max(0, origStock - reserved);

    console.debug('addToCart called', { sheetKey, row, qty, origStock, reserved, available });

    if(qty > available){
      alert('No hay suficiente stock disponible.');
      return;
    }

    const key = `${sheetKey}::${row}`;
    const existing = cart.find(i=>cartItemKey(i) === key);
    if(existing){
      existing.qty = Math.min(origStock, existing.qty + qty);
    } else {
      cart.push({ sheetKey, row, name, price: priceRaw, _priceNum: priceNum, qty });
    }

    // NO modificamos dataset.origStock aquí. Sólo `reserved` cambia (el UI usa reserved para mostrar disponibilidad).
    refreshCardStockDisplay(sheetKey,row);
    updateCartUI();

    // log del estado del carrito (después de actualizar)
    console.debug('cart state after add', { cart: JSON.parse(JSON.stringify(cart)) });

    // decrementar en servidor (serial per qty)
    updateStockOnServer_decrement(sheetKey, row, qty).catch(e=>console.warn('updateStockOnServer_decrement error', e));

    // Animación carrito
    if(cartBtn){
      cartBtn.style.animation = 'none';
      setTimeout(() => { cartBtn.style.animation = 'cartBounce 0.5s ease'; }, 10);
    }
  }

  function removeFromCart(idx){
    if(idx >= 0 && idx < cart.length){
      const item = cart[idx];
      const sheetKey = item.sheetKey;
      const row = item.row;
      const removedQty = Number(item.qty || 0);

      console.debug('removeFromCart called', { sheetKey, row, removedQty });

      // optimist increment: aumentamos reserved implícito porque eliminamos del carrito
      // NO cambiamos dataset.origStock aquí — en su lugar confiamos en la reconcilación que hará updateStockOnServer_increaseViaSet
      cart.splice(idx, 1);

      refreshCardStockDisplay(sheetKey, row);
      updateCartUI();
      openCartPopup();

      // sincronizar con servidor: read + set (increaseViaSet)
      updateStockOnServer_increaseViaSet(sheetKey, row, removedQty).catch(e => {
        console.warn('updateStockOnServer_increaseViaSet error', e);
      });

      console.debug('cart state after remove', { cart: JSON.parse(JSON.stringify(cart)) });
    }
  }

  function sendToWhatsApp(){
    if(cart.length === 0){
      alert('El carrito está vacío');
      return;
    }

    let message = '*Nuevo Pedido - Marrie*\n\n';
    let total = 0;

    cart.forEach(item => {
      const itemTotal = parsePriceNumber(item._priceNum !== undefined ? item._priceNum : item.price) * Number(item.qty||0);
      total += itemTotal;
      message += `*${item.name}*\n`;
      message += `   Cantidad: ${item.qty}\n`;
      message += `   Precio: ${Number(itemTotal).toLocaleString('de-DE')}\n\n`;
    });

    message += `*TOTAL: ${Number(total).toLocaleString('de-DE')}*\n\n`;

    const url = `https://wa.me/${WHATSAPP_NUMBER}?text=${encodeURIComponent(message)}`;
    window.open(url, '_blank');

    // Clear cart after sending
    cart = [];
    updateCartUI();

    // refrescar visual de todas las tarjetas
    document.querySelectorAll('.card').forEach(card=>{
      refreshCardStockDisplay(card.dataset.sheetKey, card.dataset.row);
    });

    closeCartPopup();
  }

  // Cart UI handlers
  function openCartPopup(){
    let html = '';
    if(cart.length === 0){
      cartItemsContainer.innerHTML = '<p style="text-align:center;color:#999">Carrito vacío</p>';
      cartTotalEl.innerHTML = '';
      cartOverlay.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      return;
    }
    cart.forEach((item, idx) => {
      const itemTotal = parsePriceNumber(item._priceNum !== undefined ? item._priceNum : item.price) * Number(item.qty||0);
      html += `
        <div class="cart-item">
          <span class="cart-item-name">${escapeHtml(item.name)}</span>
          <span class="cart-item-qty">x${item.qty}</span>
          <span class="cart-item-price">${Number(itemTotal).toLocaleString('de-DE')}</span>
          <button class="cart-item-remove" onclick="removeFromCart(${idx})">✕</button>
        </div>
      `;
    });
    cartItemsContainer.innerHTML = html || '<p style="text-align:center;color:#999">Carrito vacío</p>';
    const total = cart.reduce((s,i)=> s + (parsePriceNumber(i._priceNum !== undefined ? i._priceNum : i.price) * Number(i.qty||0)), 0);
    cartTotalEl.innerHTML = `💰 Total: <span style="color:var(--primary)">${Number(total).toLocaleString('de-DE')}</span>`;
    cartOverlay.style.display = 'flex';
    document.body.style.overflow = 'hidden';
  }
  function closeCartPopup(){ cartOverlay.style.display = 'none'; document.body.style.overflow = ''; }

  cartBtn.addEventListener('click', openCartPopup);
  cartCloseBtn.addEventListener('click', closeCartPopup);
  cartConfirmBtn.addEventListener('click', sendToWhatsApp);
  cartOverlay.addEventListener('click', (e) => { if(e.target === cartOverlay) closeCartPopup(); });
  window.removeFromCart = removeFromCart;

  /* ---------- modal de imagen ---------- */
  const imgModalOverlay = document.getElementById('img-modal-overlay');
  const imgModalImg = document.getElementById('img-modal-img');
  const imgModalClose = document.getElementById('img-modal-close');
  function openImageModal(url, alt){
    if(!url) return;
    imgModalImg.src = proxiedUrl(url);
    imgModalImg.alt = alt || '';
    imgModalOverlay.style.display = 'flex';
    imgModalOverlay.setAttribute('aria-hidden','false');
    document.body.style.overflow = 'hidden';
  }
  function closeImageModal(){ imgModalOverlay.style.display = 'none'; imgModalOverlay.setAttribute('aria-hidden','true'); imgModalImg.src = ''; document.body.style.overflow = ''; }
  imgModalClose.addEventListener('click', closeImageModal);
  imgModalOverlay.addEventListener('click', (e)=>{ if(e.target === imgModalOverlay) closeImageModal(); });

  /* ---------- helpers restantes ---------- */
  function escapeHtml(str){
    if(str === undefined || str === null) return '';
    return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  }
  function proxiedUrl(raw){
    if(!raw || typeof raw !== 'string') return '';
    return API_URL + 'image-proxy?url=' + encodeURIComponent(raw);
  }

  /* ---------- lazy-load images ---------- */
  const lazyObserver = (function(){
    if (typeof IntersectionObserver === 'undefined') return null;
    return new IntersectionObserver((entries, obs) => {
      entries.forEach(entry => {
        if (!entry.isIntersecting) return;
        const img = entry.target;
        const src = img.dataset && img.dataset.src;
        if (src) {
          img.src = src;
          delete img.dataset.src;
        }
        obs.unobserve(img);
      });
    }, {
      rootMargin: '300px 0px',
      threshold: 0.01
    });
  })();

  function observeLazyImages(rootEl) {
    if (!lazyObserver) return;
    const imgs = (rootEl || document).querySelectorAll('img[data-src]');
    imgs.forEach(img => { if (document.contains(img)) lazyObserver.observe(img); });
  }

  function makeImgEl(raw, alt, className){
    const img = document.createElement('img');
    img.alt = alt || '';
    img.className = className || '';
    try {
      img.dataset.src = proxiedUrl(raw);
      img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
    } catch(e) {
      img.src = '';
    }
    img.onerror = () => { img.remove(); };
    return img;
  }

  /* ---------- render productos: skeletons + chunks + delegation ---------- */
  function renderProducts(products, sheetKey){
    if (!products || !products.length){
      if(contentEl) contentEl.innerHTML = '<div class="loading">No hay productos</div>';
      return;
    }
    const CHUNK_SIZE = 20; // ajustar según dispositivo
    const total = products.length;

    // actualizar cache
    lastProductsCache = (products || []).map(p => {
      return {
        row: p.row,
        sheetKey: (p.sheetKey || (p.data && (p.data.Categoria || p.data.categoria)) || sheetKey || 'UNKNOWN').toString(),
        data: p.data || {}
      };
    });

    if(contentEl) contentEl.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'grid';
    contentEl.appendChild(grid);

    function createCardNodeSkeleton(p, index){
      const d = p.data || {};
      const name = firstKeyValue(d, ['name','nombre','producto','Nombre']) || d.Nombre || 'Sin nombre';
      const price = firstKeyValue(d, ['price','precio','Precio']) || d.Precio || '';
      const stock = Number(firstKeyValue(d, ['stock','cantidad','Stock']) || d.Stock || 0);
      const emojiIcon = firstKeyValue(d, ['icono','Icono','icon','emoji']) || d.Icono || '🛍️';
      const imgUrl = firstKeyValue(d, ['img','Img','imagen','image','url','Imagen']) || d.Img || '';
      const description = firstKeyValue(d, ['descripcion','Descripcion','description','desc','nota','Nota']) || d.descripcion || d.Descripcion || '';
      const productSheetKey = (p.sheetKey || d.Categoria || sheetKey || 'UNKNOWN').toString();

      const cardWrap = document.createElement('div');
      cardWrap.className = 'card';
      cardWrap.dataset.origStock = String(stock);
      cardWrap.dataset.price = price;
      cardWrap.dataset.row = String(p.row);
      cardWrap.dataset.sheetKey = String(productSheetKey);
      cardWrap.dataset._imgUrl = imgUrl || '';
      cardWrap.dataset._emoji = emojiIcon || '';
      cardWrap.dataset._desc = description || '';
      cardWrap.style.setProperty('--card-index', index);

      cardWrap.innerHTML = `
        <div class="flip-inner">
          <div class="face front">
            <div style="position:relative;padding:12px;">
              <button class="eye-toggle" aria-pressed="false" title="Ver imagen y descripción" type="button" aria-label="Ver imagen y descripción">
                <svg class="eye-open" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                  <path d="M2 12s4-7 10-7 10 7 10 7-4 7-10 7S2 12 2 12z" stroke="#ff6b9d" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <circle cx="12" cy="12" r="3" stroke="#ff6b9d" stroke-width="2"/>
                </svg>
              </button>

              <div class="front-image" aria-hidden="true">
                <div style="padding:20px;color:#ddd;font-size:2rem">🔜</div>
              </div>

              <div class="meta">
                <div class="name">${escapeHtml(name)}</div>
                <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px">
                  <div class="price">$ ${fmtPrice(price)}</div>
                  <div class="stock">Stock: <span class="stockval">${Math.max(0, stock - getReservedQty(productSheetKey, p.row))}</span></div>
                </div>
              </div>
            </div>

            <div style="padding:0 16px 16px">
              <div class="actions">
                <button class="small minus">−</button>
                <span class="qty">1</span>
                <button class="small plus">+</button>
                <button class="btn order" ${stock<=0?'disabled':''}>Pedir</button>
              </div>
            </div>
          </div>

          <div class="face back" aria-hidden="true">
            <div style="position:relative;padding:12px">
              <button class="eye-toggle" aria-pressed="true" title="Volver" type="button" aria-label="Volver">
                <svg class="eye-closed" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M19 12H5" stroke="#ff6b9d" stroke-width="2" stroke-linecap="round"/>
                  <path d="M12 19l-7-7 7-7" stroke="#ff6b9d" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
            <div class="back-image-wrap"><div style="padding:30px;color:#bbb;font-size:3rem">🖼️</div></div>
            <div style="padding:12px"><div class="desc-box">Cargando...</div></div>
          </div>
        </div>
      `;
      return cardWrap;
    }

    function populateCardDetails(card){
      try {
        const imgUrl = card.dataset._imgUrl || '';
        const emojiIcon = card.dataset._emoji || '';
        const description = card.dataset._desc || '';
        const front = card.querySelector('.face.front');
        const back = card.querySelector('.face.back');

        const frontImageWrap = front.querySelector('.front-image');
        frontImageWrap.innerHTML = '';

        if (emojiIcon && typeof emojiIcon === 'string' && !/^(https?:)?\/\//i.test(emojiIcon)) {
          const span = document.createElement('div');
          span.style.fontSize = '52px';
          span.style.lineHeight = '1';
          span.innerText = emojiIcon;
          frontImageWrap.appendChild(span);
        } else if (emojiIcon && typeof emojiIcon === 'string') {
          const smallImg = makeImgEl(emojiIcon, card.querySelector('.name')?.innerText || '', 'product-img');
          frontImageWrap.appendChild(smallImg);
        } else {
          frontImageWrap.innerHTML = '<div style="padding:18px;color:#eee;font-size:2rem">🛍️</div>';
        }

        const backImageWrap = back.querySelector('.back-image-wrap');
        backImageWrap.innerHTML = '';
        if (imgUrl && typeof imgUrl === 'string' && /^(https?:)?\/\//i.test(imgUrl)) {
          const imgLarge = makeImgEl(imgUrl, card.querySelector('.name')?.innerText || '', 'back-image');
          imgLarge.addEventListener('click', (e)=>{ e.stopPropagation(); openImageModal(imgUrl, card.querySelector('.name')?.innerText || ''); });
          backImageWrap.appendChild(imgLarge);
        } else {
          backImageWrap.innerHTML = `<div style="padding:30px;color:#bbb;font-size:3rem">🖼️</div>`;
        }

        const descBox = back.querySelector('.desc-box');
        if (descBox) descBox.innerText = description || 'Sin descripción disponible';

        observeLazyImages(card);

      } catch (err) {
        console.warn('populateCardDetails error', err);
      }
    }

    // chunk processing
    let index = 0;
    function processChunk(){
      if (index >= total) {
        console.info('renderProducts: all chunks processed', { total });
        return;
      }

      const start = index;
      const frag = document.createDocumentFragment();
      const end = Math.min(index + CHUNK_SIZE, total);
      const appendedCards = [];
      for (let i = index; i < end; i++){
        const p = products[i];
        const node = createCardNodeSkeleton(p, i);
        frag.appendChild(node);
        appendedCards.push(node);
      }
      grid.appendChild(frag);

      // log chunk cargado
      console.info('renderProducts: chunk appended', { start, end: end-1, total });

      function fillDetailsForAppended(){
        try {
          appendedCards.forEach(card => populateCardDetails(card));
        } catch(e){
          console.warn('fillDetailsForAppended error', e);
        }
      }

      if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(fillDetailsForAppended, { timeout: 300 });
      } else {
        setTimeout(fillDetailsForAppended, 80);
      }

      index = end;
      if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(processChunk, { timeout: 500 });
      } else {
        setTimeout(processChunk, 50);
      }
    }

    processChunk();

    // delegación de eventos (único listener por grid)
    if (!grid._hasDelegation) {
      grid.addEventListener('click', function(e){
        const plus = e.target.closest('.plus');
        if (plus) {
          e.preventDefault();
          const card = plus.closest('.card');
          if (!card) return;
          const qtySpan = card.querySelector('.qty');
          const current = Number(qtySpan?.innerText || '1');
          const orig = getOriginalStock(card.dataset.sheetKey, card.dataset.row);
          if (current < Math.max(0, orig - getReservedQty(card.dataset.sheetKey, card.dataset.row))){
            qtySpan.innerText = current + 1;
          }
          return;
        }

        const minus = e.target.closest('.minus');
        if (minus) {
          e.preventDefault();
          const card = minus.closest('.card');
          if (!card) return;
          const qtySpan = card.querySelector('.qty');
          const current = Number(qtySpan?.innerText || '1');
          if (current > 1) qtySpan.innerText = current - 1;
          return;
        }

        const orderBtn = e.target.closest('.order');
        if (orderBtn) {
          e.preventDefault();
          const card = orderBtn.closest('.card');
          if (!card) return;
          const qty = Number(card.querySelector('.qty')?.innerText || '1');
          addToCart(card, qty);
          return;
        }

        const eye = e.target.closest('.eye-toggle');
        if (eye) {
          e.preventDefault();
          const card = eye.closest('.card');
          if (!card) return;
          const inner = card.querySelector('.flip-inner');
          if (!inner) return;
          inner.classList.toggle('flipped');
          return;
        }
      });
      grid._hasDelegation = true;
    }
  }

  /* ---------- categorías y carga ---------- */
  async function loadCategories(){
    try {
      const r = await fetch(API_URL, {cache:'no-store'});
      const data = await r.json();
      if (!data.sheets) throw new Error("Respuesta inválida");
      availableSheetKeys = (data.sheets || []).map(s => s.key).filter(Boolean);
      renderTabs(data.sheets);
    } catch(err){
      if(tabsEl) tabsEl.innerHTML = 'Error cargando categorías';
      console.error(err);
    }
  }

  function renderTabs(sheets){
    if(!tabsEl) return;
    tabsEl.innerHTML = '';
    const allBtn = document.createElement('button');
    allBtn.className = 'tab active';
    allBtn.innerText = "✨ Todos";
    allBtn.onclick = () => {
      document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
      allBtn.classList.add('active');
      loadProductsAll();
    };
    tabsEl.appendChild(allBtn);

    sheets.forEach((s)=>{
      const btn = document.createElement('button');
      btn.className = 'tab';
      btn.innerText = s.key;
      btn.dataset.key = s.key;
      btn.onclick = ()=> {
        document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
        btn.classList.add('active');
        loadProductsFor(s.key);
      };
      tabsEl.appendChild(btn);
    });

    loadProductsAll();
  }

  async function loadProductsFor(sheetKey){
    lastLoadedSheetKey = sheetKey;
    if(contentEl) contentEl.innerHTML = '<div class="loading">Cargando productos</div>';
    try {
      const r = await fetch(API_URL+'?sheetKey='+encodeURIComponent(sheetKey), {cache:'no-store'});
      const data = await r.json();
      if (data.error){ contentEl.innerHTML='Error: '+data.message; return; }
      const products = (data.products || []).map(p=> { if(!p.sheetKey) p.sheetKey = sheetKey; return p; });
      lastProductsCache = products;
      renderProducts(products, sheetKey);
    } catch(err){ console.error(err); if(contentEl) contentEl.innerHTML='<div class="loading">Error cargando productos</div>'; }
  }

  async function loadProductsAll(){
    lastLoadedSheetKey = "ALL";
    if(contentEl) contentEl.innerHTML = '<div class="loading">Cargando todos los productos</div>';
    try {
      const r = await fetch(API_URL+'?all=1', {cache:'no-store'});
      const data = await r.json();
      if (data.error){ contentEl.innerHTML='Error: '+data.message; return; }
      let products = data.products || [];

      products.forEach(p=>{
        p.data = p.data || {};
        if(!p.data.Categoria) p.data.Categoria = p.data.Categoria || p.data.categoria || 'UNKNOWN';
      });

      const cats = [...new Set(products.map(p => (p.data && (p.data.Categoria || p.data.categoria)) ).filter(Boolean))];

      const detailsPromises = cats.map(cat => fetch(API_URL+'?sheetKey='+encodeURIComponent(cat), {cache:'no-store'})
        .then(res=>res.json().catch(()=>({products:[]})))
        .then(json => ({ cat, products: json.products || [] }))
        .catch(()=>({cat, products:[]}))
      );

      const details = await Promise.all(detailsPromises);

      const detailMap = {};
      details.forEach(obj=>{
        const cat = obj.cat;
        (obj.products || []).forEach(pp=>{
          const key = `${cat}::${String(pp.row)}`;
          detailMap[key] = pp.data || pp;
          if(!pp.sheetKey) pp.sheetKey = cat;
        });
      });

      products = products.map(p=>{
        const d = p.data || {};
        const cat = d.Categoria || d.categoria || 'UNKNOWN';
        const key = `${cat}::${String(p.row)}`;
        const det = detailMap[key];
        if(det){
          if(!d.descripcion && (det.descripcion || det.Descripcion || det.description)) d.descripcion = firstKeyValue(det, ['descripcion','Descripcion','description','desc','nota','Nota']);
          if(!d.Icono && (det.Icono || det.icono || det.icon)) d.Icono = det.Icono || det.icono || det.icon;
          if(!d.Img && (det.Img || det.img || det.imagen || det.image)) d.Img = det.Img || det.img || det.imagen || det.image;
          if(!d.Categoria && det.Categoria) d.Categoria = det.Categoria;
        }
        p.sheetKey = p.sheetKey || d.Categoria || cat;
        p.data = d;
        return p;
      });

      lastProductsCache = products.map(p => {
        return {
          row: p.row,
          sheetKey: (p.sheetKey || (p.data && (p.data.Categoria || p.data.categoria)) || 'UNKNOWN').toString(),
          data: p.data || {}
        };
      });

      renderProducts(lastProductsCache.map(p=>({ row: p.row, data: p.data, sheetKey: p.sheetKey })), "ALL");
    } catch(err){
      console.error(err);
      if(contentEl) contentEl.innerHTML = '<div class="loading">Error cargando productos</div>';
    }
  }

  // init
  loadCategories();
  updateCartUI();
</script>
</body>
</html>
